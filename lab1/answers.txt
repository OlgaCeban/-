
Часть 1: Числа Фибоначчи

а) При увеличении N с 20 до 40 с шагом 5 вычисление fib_p(N) занимает меньше 5 сек, 
а при N = 45 увеличивается время ожидания ответа, поскольку увеличивается количество
вычислений и поскольку не используется хвостовая рекурсия.
Обычная рекурсия заключается в том, что мы сначала выполняем рекурсивные вызовы, 
а затем берем возвращаемое значение рекурсивного вызова из стека и вычисляем результат. 
Таким образом, мы не получим результат вычисления, пока не вернёмся из каждого рекурсивного вызова.

б) На вычисление tail_fib(10000) тратится секунда, а может и меньше. Это происходит
из-за использования хвостовой функции. В хвостовой рекурсии сначала выполняются вычисления, 
а затем выполняется рекурсивный вызов, передающий результаты текущего шага на следующий рекурсивный шаг. 
В принципе, возвращаемое значение любого заданного рекурсивного шага совпадает с возвращаемым значением следующего рекурсивного вызова.
Следствием этого является то, что как только мы будем готовы выполнить следующий рекурсивный шаг, нам больше не понадобится текущий кадр стека.

Часть 2: Квадраты простых чисел и функция Мёбиуса

Функция Мёбиуса это простой классификатор целых чисел. 

Для положительного целого числа n, функция Мёбиуса μ(n) возвращает:

0 если число делится на квадрат простого числа
-1 если его разложение на простые сомножители состоит из нечетного числа сомножителей
1 если его разложение на простые сомножители состоит из четного числа сомножителей

Случай n = 1 особый; μ(1) возвращает 1.

Найти первый ряд из чисел делящихся на квадрат
простого числа длиной 4, длиной 5, и длиной 6. 
Нужно выбрать значение MaxN равное 30000.
Программа должна завершить вычисления в пределах одной минуты.

> mobius:find_square_multiples(4, 30000).        
[16,12,9,8,4]
> mobius:find_square_multiples(5, 30000). 
[18,16,12,9,8,4]
> mobius:find_square_multiples(6, 30000). 
[20,18,16,12,9,8,4]

Все вычисления выполнились в пределах минуты.





